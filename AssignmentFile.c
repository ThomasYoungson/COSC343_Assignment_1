#pragma config(Sensor, S1,     leftTouchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     rightTouchSensor,     sensorEV3_Touch)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* 	Constants contain threshold values for reflectance on black and white tiles. */
#define BLACKTHRESHOLD 13
#define WHITETHRESHOLD 53

/* 	Include the assignment library with a number of useful functions. */
#include "COSC343Assignment1Library.c"

/* 	Global variable to keep track of the number of tiles the robot has gone over. */
int tiles = 1;

/*  TileCount Task
*		Task to count the number of black tiles the robot goes over
*   in the lobby. Uses booleans to detect tiles correctly.
* 	@author Meaghan Bradshaw
*/
task TileCount{
	bool isTileWhite = false;
	bool isTileBlack = false;
	// While loop to keep track of what colour tile we are on.
	while (tiles<16){
		// If we're on a white tile, set the booleans to reflect so.
		if(isWhite()){
			isTileWhite =true;
			isTileBlack = false;
			} else {
			isTileWhite = false;
		}
		// If both varibles are false enter if to determine whether we're on a black tile.
		if (!isTileWhite&&!isTileBlack){
			// If we're on a black tile that we haven't detected previously, add to the count and reset booleans.
			if(isBlack()) {
				isTileBlack = true;
				playSoundFile("Boing.rsf");
				wait1Msec(200);
				isTileWhite = false;
				tiles++;
			}
		}
	}
}

/*	Path Correction Algorithim
* 	Designed to make the robot follow the grey line to the left of the black and white tiles.
* 	Color Sensor used on reflectance mode.
* 	Mathematical absolute equation used to make a adjustment to the speed of each wheel as the robot moves between tiles.
* 	On grey tiles the function returns a value between 0 and 1 depending on how far the tile is on the grey.
* 	This causes the robot to move to the right.
* 	On black or white tiles the funciton returns a value between 0 and -1 depending how far off the grey it is.
* 	This causes the robot to move towards the left.
* 	Thus the robot follows the left hand edge of the black and white tiles.
* 	A bias is added to each wheel which causes the robot to swerve onto the black and white tiles more often.
* 	@author Alexis Barltrop
*/
task PathCorrectionAlongBlackAndWhiteTiles{
	int baseSpeed = 20;
	int biasB = 35;
	int biasC = 20;
	while (tiles < 16) {
		float diff = magicFunction();
		motor[leftMotor] = baseSpeed + biasB*diff;
		motor[rightMotor] = baseSpeed - biasC*diff;
	}
}

/* 	Target Finding Task
*		Adjust the robot to face the closest target and moves forward.
*  	Repeats this until bumpers hit something.
*/
task SonarTargetFinding{
	while(SensorValue[leftTouchSensor]==0&&SensorValue[rightTouchSensor]==0){
		correctDirection();
		moveDistance(50,100);
	}
}

/*  Main
*		Steps to carry out to complete the specifications of the assignment.
*		1. Move from the start tile to the line of black and white tiles.
*		2. Do a 90 degree turn to face the elevator.
*		3. Move along tiles and count 15 black tiles.
*		4. Turn to face the tower and finish tile.
*		5. Move foward a distance to get within range
*		6. Detect the tower and move toward it
*		7. Push the tower off the finish tile and sit on it
*/
task main {

	// Step 1
	setSoundVolume(100);
	playSoundFile("Hello.rsf");
	wait1Msec(500);
	moveDistance(20,40);
	wait1Msec(500);

	// Step 2
	turnClockwise(90);
	wait1Msec(500);

	// Step 3
	startTask(TileCount);
	startTask(PathCorrectionAlongBlackAndWhiteTiles);

	// Stops everything once 15 tiles counted.
	bool tileLoop = true;
	while (tileLoop) {
		if (!(tiles < 16)) {
			stopTask(TileCount);
			stopTask(PathCorrectionAlongBlackAndWhiteTiles);
			motor[leftMotor] = 0;
			motor[rightMotor] = 0;
			tileLoop = false;
		}
	}

	// Yay 15 tiles!
	wait1Msec(500);
	playSound(soundUpwardTones);
	wait1Msec(500);

	//Step 4
	turnNinetyCorrectly();

	//Step 5
	moveDistance(200,100);

	// Step 6
	// Robot stops when it hits the tower.
	startTask(SonarTargetFinding);
	bool sonarLoop = true;
	while (sonarLoop) {
		if (SensorValue[leftTouchSensor] == 1 || SensorValue[rightTouchSensor] == 1) {
			stopTask(SonarTargetFinding);
			motor[leftMotor] = 0;
			motor[rightMotor] = 0;
			sonarLoop =false;
		}
	}
	wait1Msec(1000);

	// Step 7
	// Final Push.
	moveDistance(30, 100);
	playSoundFile("Good job.rsf");
	wait1Msec(1000);

} // End Main.
